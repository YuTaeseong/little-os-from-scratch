# Segmentation

x86의 세분화는 세그먼트를 통해 메모리에 액세스하는 것을 의미합니다. 세그먼트는 기본 주소와 제한으로 지정된 주소 공간의 일부이며 중복 될 수 있습니다. 세그먼트 메모리의 바이트 주소를 지정하려면 48 비트 논리 주소를 사용합니다. 세그먼트를 지정하는 16 비트와 해당 세그먼트 내에서 원하는 오프셋을 지정하는 32 비트입니다. 오프셋이 세그먼트의 기본 주소에 추가되고 결과 선형 주소가 세그먼트의 한계에 대해 확인됩니다 (아래 그림 참조). 모든 것이 잘 작동하면 (지금은 액세스 권한 검사가 무시 됨) 결과는 선형 주소입니다. 페이징이 비활성화되면 선형 주소 공간이 물리적 주소 공간에 1 : 1로 매핑되고 물리적 메모리에 액세스 할 수 있습니다. (페이징을 활성화하는 방법은 "페이징"장을 참조하십시오.)

세그먼트 화를 활성화하려면 각 세그먼트를 설명하는 테이블 (세그먼트 설명자 테이블)을 설정해야합니다. x86에는 GDT (Global Descriptor Table)와 LDT (Local Descriptor Tables)라는 두 가지 유형의 설명자 테이블이 있습니다. LDT는 사용자 공간 프로세스에 의해 설정 및 관리되며 모든 프로세스에는 자체 LDT가 있습니다. LDT는 더 복잡한 세분화 모델이 필요한 경우 사용할 수 있습니다.이 모델은 사용하지 않습니다. GDT는 모든 사람이 공유하며 전 세계적입니다.

가상 메모리 및 페이징에 대한 섹션에서 논의했듯이 세분화는 아래에서 수행하는 것과 유사한 최소 설정보다 더 많이 사용되지 않습니다.

## Accessing Memory

대부분의 경우 메모리에 액세스 할 때 사용할 세그먼트를 명시 적으로 지정할 필요가 없습니다. 프로세서에는 cs, ss, ds, es, gs 및 fs의 6 개의 16 비트 세그먼트 레지스터가 있습니다. 레지스터 cs는 코드 세그먼트 레지스터이며 명령어를 가져올 때 사용할 세그먼트를 지정합니다. 레지스터 ss는 스택에 액세스 할 때마다 (스택 포인터 esp를 통해) 사용되며 ds는 다른 데이터 액세스에 사용됩니다. OS는 원하는대로 레지스터 es, gs 및 fs를 자유롭게 사용할 수 있습니다.

다음은 세그먼트 레지스터의 암시 적 사용을 보여주는 예입니다.
```
    func:
        mov eax, [esp+4]
        mov ebx, [eax]
        add ebx, 8
        mov [eax], ebx
        ret
```

위의 예제는 세그먼트 레지스터를 명시 적으로 사용하는 다음 예제와 비교할 수 있습니다.
```
    func:
        mov eax, [ss:esp+4]
        mov ebx, [ds:eax]
        add ebx, 8
        mov [ds:eax], ebx
        ret
```

스택 세그먼트 선택기를 저장하기 위해 ss를 사용하거나 데이터 세그먼트 선택기를 위해 ds를 사용할 필요가 없습니다. 스택 세그먼트 선택기를 ds에 저장할 수 있으며 그 반대의 경우도 마찬가지입니다. 그러나 위에 표시된 암시 적 스타일을 사용하려면 들여 쓰기 된 레지스터에 세그먼트 선택기를 저장해야합니다. 세그먼트 설명자와 해당 필드는 Intel 설명서 [33]의 그림 3-8에 설명되어 있습니다.

>> [세그먼트 레지스터 설명](https://ko.wikipedia.org/wiki/X86_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%B6%84%ED%95%A0) 

## The Global Descriptor Table (GDT)

GDT / LDT는 8 바이트 세그먼트 설명 자의 배열입니다. GDT의 첫 번째 설명자는 항상 null 설명자이며 메모리에 액세스하는 데 사용할 수 없습니다. 디스크립터에는 기본 및 제한 필드보다 더 많은 정보가 포함되어 있기 때문에 GDT에는 최소한 두 개의 세그먼트 디스크립터와 널 디스크립터가 필요합니다. 가장 관련성이 높은 두 필드는 유형 필드와 설명자 권한 수준 (DPL) 필드입니다. Intel 설명서 [33] 3 장의 표 3-1은 유형 필드의 값을 지정합니다. 표는 유형 필드가 동시에 쓰기 가능하고 실행 가능할 수 없음을 보여줍니다. 따라서 두 개의 세그먼트가 필요합니다. 하나는 cs (Type은 Execute-only 또는 Execute-Read)에 넣을 코드를 실행하기위한 세그먼트이고 다른 하나는 데이터를 읽고 쓰기 (Type은 Read / Write)하여 다른 세그먼트 레지스터에 넣는 세그먼트입니다. DPL은 세그먼트를 사용하는 데 필요한 권한 수준을 지정합니다. x86은 0에서 3까지의 4 가지 권한 수준 (PL)을 허용하며 여기서 PL0이 가장 많은 권한을 갖습니다. 대부분의 운영 체제 (예 : Linux 및 Windows)에서는 PL0 및 PL3 만 사용됩니다. 그러나 MINIX와 같은 일부 운영 체제는 모든 수준을 사용합니다. 커널은 무엇이든 할 수 있어야하므로 DPL이 0으로 설정된 세그먼트 (커널 모드라고도 함)를 사용합니다. 현재 권한 수준 (CPL)은 cs의 세그먼트 선택기에 의해 결정됩니다. 필요한 세그먼트는 아래 표에 설명되어 있습니다.

세그먼트가 겹칩니다. 둘 다 전체 선형 주소 공간을 포함합니다. 최소 설정에서는 세분화를 사용하여 권한 수준을 얻습니다. 다른 설명자 필드에 대한 자세한 내용은 Intel 설명서 [33], 3 장을 참조하십시오.

> 학교에서 배운 페이징과 다른 기법이다.

> GDT를 정의하는 과정이다. 3가지 종류의 Descriptor을 정의한다. 하나는 null, 하나는 code segment를 위한 것. 마지막으로 data segmanet를 위한 것

> intel manual 3-12를 참고하자.

> Logical Address가 세그멘테이션을 거치면 Linear Address Space에 매칭되고 Lineaer Address가 페이징을 거치면 Physical Address space에 매칭된다.

> segment Register : To reduce address translation time and coding complexity, the processor provides registers for holding up to 6
segment selectors (see Figure 3-7).(intel manual 3-8)

## Loading the GDT

이 명령어를 C에서 사용할 수 있도록하면 어셈블리 코드 명령어를 입력 및 출력 할 때와 같은 방식으로 사용하는 것이 더 쉬울 수 있습니다. GDT가 로드 된 후 세그먼트 레지스터는 해당 세그먼트 선택기와 함께로드되어야합니다. 세그먼트 선택기의 내용은 아래 그림과 표에 설명되어 있습니다.

세그먼트 선택기의 오프셋은 세그먼트 설명 자의 주소를 얻기 위해 GDT의 시작 부분에 추가됩니다. 각 설명자는 8 바이트이므로 첫 번째 설명 자의 경우 0x08, 두 번째 설명 자의 경우 0x10입니다. 요청 된 권한 수준 (RPL)은 OS 커널이 권한 수준 0에서 실행되어야하므로 0이어야합니다. 데이터 레지스터의 경우 세그먼트 선택기 레지스터를 쉽게로드 할 수 있습니다. 레지스터에 올바른 오프셋을 복사하기 만하면됩니다.

멀리 점프는 전체 48 비트 논리 주소 (사용할 세그먼트 선택기 및 점프 할 절대 주소)를 명시 적으로 지정하는 점프입니다. 먼저 cs를 0x08로 설정 한 다음 절대 주소를 사용하여 flush_cs로 점프합니다.